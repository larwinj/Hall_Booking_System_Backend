"""Autogenerate a simple Alembic migration for newly added columns and apply it.

This script inspects SQLAlchemy models vs the DB and creates a one-off Alembic revision
that adds missing simple columns (string/int/bool). It then runs `alembic upgrade head`.

WARNING: This script only handles adding simple columns and creates a revision file;
inspect the created migration before applying in production.
"""
import os
import re
import uuid
import datetime
import subprocess
from pathlib import Path
from typing import Optional

from sqlalchemy import create_engine, inspect, String, Integer, Boolean
from sqlalchemy import Table, MetaData
from sqlalchemy.sql.sqltypes import NullType

# Import your app models / metadata
from app.core.config import get_settings
from app.db.base import *  # noqa: F401,F403 - ensure model registrations are imported
from app.models.user import User  # adjust import if your User model location differs

# ---- Paths ----
BASE_DIR = Path(__file__).resolve().parent.parent  # repo root (assumes scripts/ is inside repo)
ALEMBIC_VERSIONS = BASE_DIR / "alembic" / "versions"
ALEMBIC_VERSIONS.mkdir(parents=True, exist_ok=True)  # ensure versions dir exists

# ---- DB engine & inspector ----
settings = get_settings()
# Remove async driver suffix if present (your original approach)
url = settings.POSTGRES_URL.replace("+asyncpg", "")
engine = create_engine(url)
inspector = inspect(engine)

missing_ops = []

# ---- Inspect DB and models ----
# Use the mapped Table from the model
user_table: Table = User.__table__
model_cols = {c.name: c for c in user_table.columns}

# Get DB columns (if table doesn't exist, abort)
try:
    db_cols = {c["name"]: c for c in inspector.get_columns(user_table.name)}
except Exception as e:
    print(f"Error inspecting DB table '{user_table.name}': {e}")
    raise SystemExit(1)

# Only add "simple" scalar columns (String, Integer, Boolean)
for name, col in model_cols.items():
    if name in db_cols:
        continue

    coltype = col.type
    sa_type: Optional[str] = None

    # Prefer type-checking by SQLAlchemy classes imported above.
    # Some dialect-specific types still subclass these, so isinstance is acceptable.
    if isinstance(coltype, String):
        length = getattr(coltype, "length", None)
        if length:
            sa_type = f"sa.String(length={length})"
        else:
            sa_type = "sa.String()"
    elif isinstance(coltype, Integer):
        sa_type = "sa.Integer()"
    elif isinstance(coltype, Boolean):
        sa_type = "sa.Boolean()"
    else:
        # skip complex/unsupported types
        sa_type = None

    if sa_type:
        nullable = col.nullable
        missing_ops.append((name, sa_type, nullable))

if not missing_ops:
    print("No missing simple columns detected; nothing to do.")
    raise SystemExit(0)

# ---- Determine down_revision ----
def find_latest_revision_id(versions_dir: Path) -> Optional[str]:
    """Try to read the latest revision id by reading 'revision = ' in newest file."""
    py_files = sorted(versions_dir.glob("*.py"), key=lambda p: p.stat().st_mtime)
    if not py_files:
        return None
    latest = py_files[-1]
    text = latest.read_text(encoding="utf8")
    m = re.search(r"^revision\s*=\s*['\"]([^'\"#]+)['\"]", text, re.MULTILINE)
    if m:
        return m.group(1)
    return None

head_rev = find_latest_revision_id(ALEMBIC_VERSIONS)
down_revision = f"'{head_rev}'" if head_rev else "None"

# ---- Build migration content ----
# Use a safe, short revision id (timestamp + uuid4 short)
timestamp = datetime.datetime.utcnow().strftime("%Y%m%d%H%M%S")
rev_id = f"autogen_{timestamp}_{uuid.uuid4().hex[:8]}"

ops_lines = []
for name, sa_type, nullable in missing_ops:
    ops_lines.append(f"    op.add_column('{user_table.name}', sa.Column('{name}', {sa_type}, nullable={nullable}))")

downgrade_lines = []
for name, _, _ in missing_ops:
    downgrade_lines.append(f"    op.drop_column('{user_table.name}', '{name}')")

created_iso = datetime.datetime.utcnow().isoformat()

revision_header = f"""\"\"\"Autogenerated migration: add missing simple columns to `{user_table.name}` table

Revision ID: {rev_id}
Revises: {head_rev or ''}
Create Date: {created_iso}
\"\"\"\n
"""

migration_body = f"""from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '{rev_id}'
down_revision = {down_revision}
branch_labels = None
depends_on = None


def upgrade():
"""

for l in ops_lines:
    migration_body += l + "\n"

migration_body += "\n\ndef downgrade():\n"
for l in downgrade_lines:
    migration_body += l + "\n"

content = revision_header + migration_body

# ---- Write revision file ----
rev_file = ALEMBIC_VERSIONS / f"{rev_id}_add_missing_columns.py"
rev_file.write_text(content, encoding="utf8")
print("Wrote revision file:", rev_file)

# ---- Run alembic upgrade head ----
print("Running alembic upgrade head...")
# Use same python interpreter (cross-platform) to run alembic module
try:
    subprocess.run([os.sys.executable, "-m", "alembic", "upgrade", "head"], check=True)
    print("Alembic upgrade completed.")
except subprocess.CalledProcessError as e:
    print("Alembic upgrade failed:", e)
    print("Inspect the generated revision file and run alembic manually if needed.")
    raise SystemExit(1)
